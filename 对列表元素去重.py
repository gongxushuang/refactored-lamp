#对列表中重复的元素去除，只留下具有互异性的列表
#我们的思路肯定就是从对列表元素进行一个遍历开始
#对每一个列表元素，我们没有学过有关于列表中每个元素的重复个数知识
#只能重新建立新思路，我们可以建立一个新的空列表，对列表的每一个元素放进新列表
#然后再放置的过程中，进行比较，已有的就不再加入
def get_unique_list(lista):
    result=[] #建立一个变量来储存我们的输出结果
    for i in lista: #下面我们就要往列表里面放元素，放的时候要判断
        if i not in result:
            result.append(i)
    return result
print(get_unique_list([1,2,3,4,5,4,5,6]))
#在python中还有一个set()，是创建集合的意思，而集合满足互异性
#set(lista)就是以lista为材料创建集合，实现自动去重
#list(set(lista))即将集合再次转化成列表，保持列表性质不变，同时用集合去重

#但是这里有一个重要的知识点，就是hash
#你在操作list(set(lista))时就会发现输出之后元素顺序会改变
#这是因为集合具有无序性，在列表转集合时，集合按照集合自己的哈希表存储机制对内元素进行了重组
#这使得原来的顺序信息完全丢失
#这里我们先介绍hash
#hash是指一种单向的数学函数，将任意大小的数据转换成固定长度的字符串，这个输出值就叫哈希值
#但是你无法从输出值还原原数据这就是hash的单向性
  #同时它还具有确定性，即一一对应（单射）
  #能实现快速计算，复杂度低
  #雪崩效应，一个微小改变将导致哈希值巨大的变化
#可hash就是指不可变数据，这样对应的hash值固定，比如int,float,str,tuple,bool,frozenset
#不可hash就是指可变数据，hash一直在改变，无法取得一个固定hash值，比如list，dict，set，自定义可变对象
#但是集合和字典里面的元素需要可hash元素，而列表不需要
#因为列表本身在运行时就是通过遍历来进行，他有自己的顺序，比如你的那个列表第一个元素实际是list[0],他不需要依赖于hash
#而集合正是因为没有顺序，但是python中集合要求快速，他就必须对输入的每一个元素都求一个hash值
#将元素与hash值对应起来，进行元素的定位查找，通过hash的快速计算，来实现快速运行
#如果集合输入了一个不可hash元素，那你的hash会变，就会导致这个元素无法通过存储固定hash值来找到，导致元素数据丢失！
#综上，list(set(lista))会导致顺序改变，如果不要求顺序，这个方法是OK的
#如果要保留顺序性，那么可以用相同逻辑的list(dict.fromkeys(lista))
#但是以上的两种都要求元素可hash，因为中间的转换包含集合和字典
#要么就是循环判断not in，保持顺序且对元素类型无要求，速度慢





